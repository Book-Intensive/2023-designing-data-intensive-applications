# 8주차 - 분산 시스템의 골칫거리

분산 시스템에서는
- 수천 개의 노드가 있는 시스템에서는 항상 뭔가 고장난 상태라고 가정하는게 합리적이다. 
- 시스템이 장애 난 노드를 감내할 수 있고 전체적으로 계속 동작할 수 있다면 운영과 유지보수에 매우 유용한 특성이 된다.
분산 시스템이 제대로 동작하게 만들려면 신뢰성 없는 구성 요소를 사용해 신뢰성 있는 시스템을 구축해야 한다.


## 신뢰성 없는 네트워크
---
네트워크 결함이 드물더라도 일어날 수 있다는 것은 소프트웨어아 이 결함을 처리할 수 있어야 한다는 뜻이다.

### 결함 노드 자동 감지
자동 감지하여 다음과 같은 일을 처리해야 한다.
- 죽은 노드로 요청 그만 보내기
- 리더가 장애 시 팔로워 중 하나를 리더로 승격

자동 감지는 보통 여러번의 재시도와 타임아웃을 통해 감지한다. 그렇다면 **타임아웃은 얼마나 길어야 할까?** 타임아웃을 너무 길게 잡으면 감지까지 긴 시간이 걸리는 것이고 너무 짧게 잡으면 실제로 결함이 발생한 것은 아니고 트래픽으로 인해 지연 전송이 되었을때 더 큰 문제가 발생한다.(트래픽으로 고통받고 있는데 새로운 노드가 클러스터에 추가되는 등의 행동이 더해지므로)

보통 지연이 되는 현상은 **네트워크 혼잡과 큐 대기**로 인해 일어난다. 이러한 현상을 가지고 타임아웃 시간을 정확히 예측하기 힘들다. 따라서 타임아웃에 올바른 값은 없으며 **실험을 통해 결정**해야 한다.


## 신뢰성 없는 시계
---
분산 시스템에서 모든 노드의 로컬 시계나 동일하기는 힘들다. 동기화를 한다고 해도 네트워크 지연시간과 처리시간 등의 시간차이가 있기때문에 미세한 시간의 차이라도 있기 마련이다. 

### 단조 시계와 일 기준 시계
**일 기준 시계**
- 네트워크 시간 프로토(NTP)로 서버 그룹에서 보고한 시간에 따라 노드들의 시계를 조정
- 한 노드의 시간이 갑자기 역행할 수 있음(이미 지난 시간으로 조정)

**단조 시계**
- NTP를 이용하지만 시간을 역행시키지 않는다. 노드의 시간을 천천히 흐르도록 만든다.
- 일 기준 시계는 시간이 역행할 수 있기 때문에 지속시간(시간 구간)을 재는데 적합하지 않지만 단조시계는 앞으로만 흐르기 때문에 실행시간을 구하는데 적합하다.

### 시계에 의존했을때의 문제점
두 트랜잭션의 동시 쓰기 후 전파에서 실제적으로는 시간상 B가 늦게 업데이트했지만 전파한 노드의 시계가 A의 시간보다 빨랐기 때문에 수정이 되지 않는다.(그림 8-3)

위 상황은 쓰기 충돌 해소 전략으로 최종 쓰기 승리(LWW, last write, wins)라고 부르는 방식인데 시계로 인해 위 문제가 발생할 수 있다.


### 스냅숏 격리에서의 동기화된 시계
스냅숏 격리는 다중 버전을 이용한다. 즉, transactionID가 중요하다. 하지만 여러 파티션에 걸쳐 있을때, 시계를 기준으로 하는 transactionID는 문제가 될 수 있다.

### 시계 읽기의 신뢰 구간을 이용하기
각 트랜잭션마다 `{가장 이른 시계, 가장 늦은 시계}`로 구간을 만들고 A구간 < B구간일때 B가 A보다 이후에 실행되었다고 확신할 수 있다.

### 프로세스 중단 문제
노드가 여전히 리더인지를 어떻게 알 수 있을까? 한 방법으로 노드가 임차권을 가지고 일정시간마다 임차권을 갱신하면서 여전히 건재하다는 것을 증명하는 방식을 사용할 수 있다.

하지만 프로세스나 쓰레드는 언제나 중단될 수 있다. 예를 들어, GC의 동작으로 인한 `stop-the-world` 현상과 같은 것들이다. 이러한 프로세스 중단 문제를 커버하기 위해 엄격한 실시간 시스템을 사용하거나 GC의 영향을 제한하는 방식을 사용할 수 있다.


## 지식, 진실, 그리고 거짓말
---
분산 시스템에는 큰 신뢰할 수 없는 네트워크를 통해 메시지를 보낼 수 있을 뿐이며, 부분 장애, 신뢰성 없는 시계, 각 노드의 프로세스 중단 문제가 발생할 수 있다.

분산 시스템에서는 어떤 노드의 상태를 확실히 알지 못한다. **오직 네트워크로 전달받은 메시지를 통해서 어떤 상태인지 알 수 있을 뿐이다.** 응답하지 않으면 네트워크 문제인지, 노드 자체의 문제인지 확실히 구별하기 어렵다.

분산 시스템에서 우리는 동작에 관해 정한 가정을 명시하고, 이 가정을 만족시키는 방식으로 설계할 수 있다. 하지만 이러한 설계가 가능할지는 몰라도 쉽지는 않다.


### 다수결 결정이 필요한 이유
노드가 상황에 대한 자신의 판단을 반드시 믿을 수 있는 것은 아니다.
- 정족수 사용하기 (분산 시스멤에 속하는 노드들 중 과반수로 동의하는 것 - 과반수가 동의하면 저 노드는 죽은 것이다.)

### 리더가 필요할 때 생기는 문제
임차권을 가지고 쓰레드가 잠시 멈추었다가 다시 돌아갔을때 임차권이 만기되었는지 모르고 사용하는 문제
- 펜싱토큰(임차권의 버전을 가짐)을 이용하여 해당 임차권이 이전버전의 임차권인지 알 수 있음

### 노드 중 거짓말을 하는 노드가 존재
- 비잔팀 결함(시스템의 특정 노드가 오염된 응답을 보내는 경우)으로 신뢰할 수 없는 환경이 생길 수 있음
- 비잔틴 장군 문제는 이러한 신뢰할 수 없는 환경에서 합의에 도달하는 문제이다.
- 일부 노드의 오작동, 악의적인 공격자가 네트워크를 방해하더라도 시스템이 올바르게 동작한다면 **비잔틴 내결함성을 지닌다**라고 한다.
- **피어투피어 시스템에서 발생가능**(중앙 권한이 없는 시스템), 일반적잉 웹 생태계에서는 이런 경우는 없다고 봐도 무방하다.

### 시스템 모델

타이밍 가정에 대한 시스템 모델
- 동기싱 모델(네트워크, 프로세스 중단, 시계 오차에 모두 제한이 있음)
- 부분 동기식 모델(때때로 네트워크, 프로세스 중단, 시계 오차이 한계치를 초과함)
- 비동기식 모델(타이밍에 대한 어떤 가정도 할 수 없음)

노드에 관한 시스템 모델
- 죽으면 중단하는 결함
- 죽으면 복구하는 결함(노드가 순간 죽을 수는 있지만 시간이 흐른 후에는 아마도 다시 응답할 것)
- 비잔틴 결함

위와 같은 모델들에 대응하기 위한 알고리즘을 짜는 방법
- 알고리즘의 속성을 기술하고, 모든 가정(위 시스템 보델) 속에서 이 속성이 만족한다면 알고리즘이 정확하다고 할 수 있다.
- 속성에는 안정성(한번 깨지면 손상된 것)과 활동성(결국에는 원하던대로 된다)이 존재


### 기습 퀴즈(2개)
스터디 끝나고 난 후 커밋(답변과 함께)
- Q.
```text
승리: ???
록원: !!!
```  

- Q.
```text
승리: ???
록원: !!!
``` 


### 본인이 이해 안되었던 부분
- 시계 구간은 무슨 의미가 있는걸까?

### 좀 더 공부한 부분
- 

### 논의하고 싶은 부분
- 
