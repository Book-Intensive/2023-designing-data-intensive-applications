# 9주차 - 일관성과 합의

결함을 다루는 가장 간단한 방법은 전체 서비스가 실패하도록 두고 **실패 시 사용자에게 오류 메시지를 보여주는 것**이다.
그렇지 않을 것이라면, 내무 구성 요소에서 특정 노드가 **결함이 있더라도 이를 견뎌내고 서비스가 올바르게 동작하게 할 방법을 찾아야 한다.**

이러한 방법 중 하나로 **문제를 무시할 수 있게 만들어 주는 추상화** 방법이 있다.
- 한 예는 분산 시스템의 모든 노드가 어떤 것에 동의하게 만드는 방법이 있다. 즉, `합의`를 하는 것이다.
	- 합의를 통해 새로운 리더를 뽑을 수 있다.(올바른 합의는 스플릿 브레인 회피 가능)

### 강한 일관성의 필요성
최종적 일관성은 '불일치는 일시적이고 결국 일관된 형태를 가질 수 있음'을 의미한다.
- 최종적 일관성의 엣지 케이스는 시스템 결함이 있거나 동시성이 높을 때 분명히 드러난다.
- 따라서, 성능이 저하되고, 내결함성이 약할지라도 **강한 일관성이 필요한 때가 있다.**

### 선형성(linearizability) 보장하기
약한 일관성에서는 두 개의 다른 복제 데이터베이스에 같은 질의 시 다른 응답을 받을 수 있다. 만약 데이터베이스의 **복제본이 하나만 있다는 환상을 만들어준다면 단순하지 않을까?** 이것이 선형성을 뒷받침하는 아이디어다.
(원자적 일관성, 강한 일관성, 즉각 일관성, 외부 일관성 이라고 부르기도 한다.)

**선형성이 중요한 예시**
- 리더 선출(모든 노드가 어떤 노드가 잠금을 소유하는지에 동의해야하고 리더가 되어야함, 리더가 잠금을 소유)
- 제약 조건과 유일성 보장이 필요할때(잠금, 은행 계좌 잔고, 특정 좌석 예약)
- 타이밍 의존성이 필요할때(A에서 작업 후 B가 A의 작업물을 사용할 때, 아직 작업물이 만들어지지 않았으면 힘든)

**선형성의 비용**
- 선형성은 결국 고가용성(내결함성)과 일관성 간의 트레이드오프이다.
- 선형성을 선택한다면 모든 노드의 업데이트, 비동기 전파를 사용하지 못하고 지연시간이 늘어난다.
	- 선형성을 선택했을때, 구성 노드 중 네트워크 연결이 끊긴 것이 존재한다면 복구할때까지 기다려야 한다. 즉, 그 시간동안 프로세스가 잠시 중단되거나 클라이언트에게 오류 메시지를 보내야한다.
- 따라서, 선형성을 사용하지 않는 이유는 **성능** 때문이다.

### 순서화 보장하기
선형성에서 '복제본이 하나만 있다는 환상을 만들어준다면 단순하지 않을까?' 라고 이야기 했다. 즉, 복사본이 하나로 동작하고 모든 연상이 어느 시점에 원자적으로 효과가 나타나는 것처럼 보인다고 했다.이 정의는 시도되는 연산들이 **정의된 순서대로 실행되는다는 것**을 암시한다. 다시말해, 선형성와 순서화, 합의 사이에 깊은 연결 관계가 있다는 것이다.

순서라는 것은 인과성이 있다는 의미이다. 원인이 먼저 일어나야 결과가 존재할 수 있다는 것. 선형성은 인과성을 내포하며 동시성을 제어할 수 있다. 모든(전체) 연산에 순서를 정할 수 있다. 어떤 일이 동시에 일어나더라도 선형성은 모든 연산의 순서를 제어할 수 있다. 하지만 인과성 만을 가진다면, 어떤 두 가지 일이 동시에 실행되었을때 이를 비교할 수가 없다.

선형성은 비용이 크지만 인과성은 동시성을 직접 제어하지 않기 비용이 적게 든다. 하지만 동시성을 제어하지 않으면 일관성에 큰 영향을 미친다. 이를 절충한 것이 바로 인관적 일관성이다.(가용성을 가져가며 최종적 일관성보다 강한 일관성을 가져갈 수 있다)

인과적 인과성이 동시실행에서 인과를 가져가기 위한 방법
- 의존성을 추적하는 방법이 있다.(버전 벡터)
- 일련번호 순서화(일련번호(증가 id) 와 같은 논리적 시계를 이용하여 순서맞추기)
- 램포드 타임스탬프를 이용
	- (카운터, 노드 ID) 쌍을 이용
	- 문제는 노드 내 동기화가 비동기적(동시에 다른 노드에 같은 닉네임을 가지는 유저가 생기면 막을 수 없다.)
	- **전체 순서 브로드캐스트를 통해 모든 노드와 순서 정하기**
		1. 쓰기 시 로그 작성 (로그에 일련번호 달기)
		2. 모든 노드에 로그 전파
		3. 모든 노드에서 받아온 메시지 확인 - 일련번호보다 작은 일련변호로 닉네임을 점유하고자 하는 메시지 존재 시 어보트 그 이외에 OK

### 내결함성을 가진 합의

**합의가 필요한 경우**
- 리더 선출
- 원자적 커밋 - 여러 노드나 파티션에 걸친 트랜잭션 

**분산 트랜잭션 구현**
- 2PC(2단계 커밋)
	- 1차적으로 모든 노드에 준비 확인, 2차적으로 커밋 하는 방법
	- 모든 노드와 소통하는 코디네이터 필요
	- 코디네이터 장애시 트랜잭션에 참여하는 노드가 커밋 or 어보트 무한대기, 노드에 장애시 코디네이터가 장애 복구할때까지 무한 요청
	- 코디네이터 구현은 기본적으로 고가용성을 제공하지 않거나 가장 기초적인 복제만 지원한다.
- 내부 분산 트랜잭션
	- 분산 데이터베이스가 자체적으로 제공해줌
- 이종 분산 트랜잭션
	- 서로 다른 데이터베이스를 사용하는 경우의 트랜잭션
	- XA(eXtended Architecture) 트랜잭션 - 2단계 커밋을 구현하는 표준

**합의**
- 합의 알고리즘들은 전체 순서 브로드캐스트 메커니즘을 구현한다.
- 합의 알고리즘들 통해 분산 시스템에서 내결함성과 일관성을 모두 달성할 수 있다. 하지만 비용이 적지 않다.
- 정족수를 통해 리더를 선출한다.

**합의를 지원하는 코디네이션 서비스**
- 주키퍼나 Raft 등의 서비스들이 존재
- 추가적으로 연산의 전체 순서화(펜싱 토큰 지원), 장애를 감지하는 법, 클러스터 내 새로운 노드 추가와 장애 확인 등 변경 알림, 클러스터 내 서비스 찾기(Service Discovery) 기능을 지원해준다.



### 기습 퀴즈(2개)
스터디 끝나고 난 후 커밋(답변과 함께)
- Q.
```text
승리: ???
록원: !!!
```  

- Q.
```text
승리: ???
록원: !!!
``` 


### 본인이 이해 안되었던 부분
- 

### 좀 더 공부한 부분
- 

### 논의하고 싶은 부분
- 
