# 7주차 템플릿


## 완화된 격리수준
- 커밋 후 읽기
- 스냅숏 격리(MySQL에서는 REPEATABLE READ, Oracle에서는 직렬성)
	- 트랜잭션 시작시 트랜잭션 ID(버전)을 붙이고 버전 아래의 값만을 읽는 방식
	- 멀티 버전 동시성 제어(MVCC)라고 부른다.


### 쓰기 충돌 (갱신 손실 발생) 의 해결법
read-modify-write 주기 내에서 발생할 수 있다. (이 주기가 동시에 실행될 경우 발생)  

- 원자적 쓰기 연산
	- 하나의 주기가 하나의 원자적 단위로 실행되도록(사실상 그 구현체는 독점적인 잠금을 획득하는 것)
- 명시적인 잠금
	- 다른 트랜잭션들은 주기가 완료될때까지 기다리도록
	- 어딘가에 잠금을 추가하는 것을 잊어버려서 경쟁조건을 유발하기 쉬움
- 갱신 손실 자동 감지
	- 병렬 실행을 허용하고 트랜잭션 관리자가 갱신 손실을 발견하면 어보트 시키고 재시도를 강제하는 방법
	- 병렬 실행이 가능하고 충돌시에 자동 어보트-재시도 되어 성능상 이점?
- Compare-and-set
	- 갱신 손실을 회피하는 방법
	- 마지막 값을 읽은 뒤 내용이 바뀌지 않았을떼만 갱신


### 팬텀으로 인한 쓰기 스큐문제
- 어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 것을 `팬텀` 이라고 부른다. 이러한 팬텀이 쓰기 스큐를 유발하게 된다.
- 쓰기 스큐는 두 트랜잭션이 다른 객체를 갱신할때 생기는 문제

---

## 직렬성
여러 트랜잭션이 병렬로 실행되더라도 최종 결과는 동시성 없이 한 번에 하나씩 직렬로 실행될 때와 같도록 보장하는 방법이다. 이 방법은 데이터베이스에서 발생할 수 있는 모든 경쟁 조건을 막아준다.

### 직렬성을 위한 기법
- 트랜잭션 순차적 실행
- 스토어드 프로시저
	- 트랜잭션을 스토어드 프로시저 안에 캡슐화하기
	- 모든 질의를 한번에 보내는 것(일반적으로 트랜잭션은 질의를 하나씩 보내고 마지막에 롤백 or 커밋)
- 2단계 잠금(2PL, tow-phase locking)
	- 쓰기 트랜잭션은 읽기 트랜잭션도 진행하지 못하게 막고 그 역도 성립한다.(읽을 트랜잭션 시 쓰기 트랜잭션도 못하게 막는다.)
	- 읽을 때 공유 잠금 획득, 쓸때 공유잠금 -> 독점 잠금으로 업그레이드 (어떤 잠금을 가지고 있든 다른 트랜잭션은 해당 객체에 접근하지 못하고 기다림)
	- 트랜잭션이 종료 될때까지 잠금을 갖고 있는다.
	- 잠금을 많이 사용하다보니 교착상태에 빠직 쉬움. 데이터베이스가 자동 감지하여 교착상태 중인 트랜잭션을 어보트시켜야 함. 어보트된 트랜잭션은 어플리케이션에서 재시도해야함.
	- 성능 문제가 발생
	- 비관적 동시성 제어
> [!info] 서술잠금
> 쓰기 스큐를 막기 위한 방법으로 잠금을 하나의 객체가 아닌 특정 범위 속하는 모든 객체를 잠금하는 방식. 미래에 추가될 수 있는 객체에도 적용할 수 있다. 2단계 잠금에 서술 잠금을 포함하면 격리수준이 직렬성 격리가 될 수 있다.

> [!info] 색인범위 잠금
> 색인에 잠금을 거는 방법(잠금을 걸 적합한 색인이 없다면 테이블 전체에 잠금을 걸 수도 있음)


- 직렬성 스냅숏 격리(SSI)
	- 단일 노드, 분산 데이터베이스 모두에서 사용된다.
	- 낙관적 동시성 제어 방법(비관적 동시성 제어는 상황이 다시 안전해질때까지 기다리는게 낫다는 원칙)
	- 스냅숏 격리에서 - 트랜잭션에서 실행되는 모든 읽기는 일관된 스탭숏을 본다.
	- A 트랜잭션 내에서 이전에 읽었던 데이터가 다른 트랜잭션이 읽어 쓰기를 하고 커밋을 했다면 A 트랜잭션은 어보트 당함
	- 데이터베이스는 색인 범위를 잠그고 어떤 트랜잭션이 접근했는지를 기록하여 다른 트랜잭션이 해당 데이터를 변경했는지 알 수 있게 해준다.





### 기습 퀴즈(2개)
스터디 끝나고 난 후 커밋(답변과 함께)
- Q.
```text
승리: ???
록원: !!!
```  

- Q.
```text
승리: ???
록원: !!!
``` 


### 본인이 이해 안되었던 부분
- p21 - 색인과 스냅숏 격리 (이해가 어렵다. 그래서 멀티버전에서 인덱스는 어떻게 관리된다는 것인가)

- p243 - 불행하게도 객체 관계형 매핑 프레임워크를 사용하면 뜻하지 않게 데이터베이스가 제공하는 원자적 연산을 사용하는 대신 불안전한 read-modify-write 주기를 실행하는 코드를 작성하기 쉽다. -> 예시가 있었으면...


### 좀 더 공부한 부분
- 

### 논의하고 싶은 부분
- `스냅숏 격리는 자동으로 쓰기 충돌을 막아주는 거 아닌가? DB마다 이 쓰기 충돌을 막아주는 방법이 다르다는 것을 설명하는 것인가?`